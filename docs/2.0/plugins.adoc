== Allure Plugins System

Allure is designed to be highly customizable, because practice shows that many teams across the world
may have different metrics, or may have developed unique approaches for testing, their products might demand
something completely different to the initial requirements Allure was built to comply. To deal with this
kinds of challenges Allure has a plugin system, that gives a lot of flexibility to the report representation.

To be precise, all of the basic functionality is modularized into plugins, and it would be too lengthy to list
them all here. But nearly every feature described in the features section [link to allure features section]
 is implemented internally as a plugin.

=== Plugin structure

Basically, any plugin will be constituted of two main parts:

* *Java classes* that process the report data and produce some results in the report folder.
* *JS script* that takes stored results and creates a representation for them on the report's front-end side,
e.g. a widget or an additional tab.

Typical structure of a plugin module would look like this:

[source]
----
/my-plugin
    /src
        /dist
            /static
            allure-plugin.yml
        /main
            /java
                /my.company.plugin
    build.gradle
----

Here in `src\dist\static` all the static JavaScript files are stored, and everything under `src\main\java`
is a data processing Java code. `allure-plugin.yml` - is a configuration file.

=== Contents of allure-plugin.yml file

This file contains directives in human-readable format that plugin loader will further use to locate resources
 and connect the plugin.

[source, yml]
----
id: my-plugin
name: Plugin name goes here
description: More detailed explanation of what does this plugin do.
extensions:
- my.company.allure.CustomPlugin // - Fully qualified names of classes that implement `Extension` interface and comprise data processing functionality.
- my.company.allure.CustomWidget
jsFiles:
- index.js
cssFiles:
- styles.css
----

=== Adding allure-plugin-api dependency

To be able to use the API you should simply download the `allure-plugin-api` dependency
link:https://mvnrepository.com/artifact/io.qameta.allure/allure-plugin-api[from] the jcenter repository.
To do so add to your project build script:

in Gradle:

[source, groovy]
----
dependencies {
    compile('io.qameta.allure:allure-plugin-api:${allureVersion}')
}
----

in Maven:
[source, xml]
----
        <dependency>
            <groupId>io.qameta.allure</groupId>
            <artifactId>allure-plugin-api</artifactId>
            <version>${allureVersion}</version>
        </dependency>
----

=== Plugin distribution

When you build a plugin, you should come up with the following structure, which then can be copied into `plugins` folder
of the commandline distribution.

[source]
----
\my-plugin
    allure-plugin.yml
    plugin.jar
    \lib
        dependency.jar
    \static
        styles.css
        index.js
----

 * *plugin.jar* - is a jar with your compiled plugin classes
 * *\lib* - all of your pugin's dependencies should be placed in here
 * *\static* - a folder containing all static `.js` and `.css` files.

Here is a template of gradle build script for a plugin project that uses
link:https://docs.gradle.org/current/userguide/javaLibraryDistribution_plugin.html[Java Library Distribution Plugin]
to package plugin classes and copy files and dependencies into one .zip archive.

[source, groovy]
----
repositories {
    jcenter()
}

apply plugin: 'java-library-distribution'

jar {
    archiveName = 'plugin.jar'
}

dependencies {
    compile('io.qameta.allure:allure-plugin-api:2.0-BETA8')
}
----

=== Enabling a plugin

=== Java Plugin API overview
Let's take a look into the class diagram of the top classes in the Allure plugins system.

image::plugins_api_uml_diagram.png[Top interfaces hierarchy]

Plugin classes can extend 3 basic interfaces that provide different aspects of functionality:

 * *Reader* allows to implement a `readResults` method, which defines the logic of reading results with `ResultsVisitor`
 instance from the directory with test results.
 * *Aggregator* allows to implement `aggregate` method, which defines the logic of aggregating processed results across
 all the results folders, and write resulting data to the report directory.
 * *Widget* this interface allows to implement `getData` method which again defines the logic of processed results aggregation
 but this time resulting data is saved into the `widget.json` file to be used by the widget named accordingly to the value
 supplied in `getName`.

A fourth, *Context<T>* interface with `T getValue()` method enables to create some utility class to be used for all
 plugins via a method `Configuration.requireContext(Class<T>)` available from a Configuration instance, provided as
 a parameter in all of the 3 methods above.

A quick example of such an utility class would be `JacksonContext`, which is used to obtain an `ObjectMapper` instance
 allowing to serialize Java objects with data into the report JSON files.

[source, java]
----
public class JacksonContext implements Context<ObjectMapper> {

    private final ObjectMapper mapper;

    public JacksonContext() {
        this.mapper = new ObjectMapper()
                .configure(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME, true)
                .setAnnotationIntrospector(new JaxbAnnotationIntrospector(TypeFactory.defaultInstance()))
                .enable(SerializationFeature.INDENT_OUTPUT)
                .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
                .setSerializationInclusion(JsonInclude.Include.NON_NULL);
    }

    @Override
    public ObjectMapper getValue() {
        return mapper;
    }
}
----

Then, from a plugin class it can be used as follows:

[source, java]
----
@Override
public void aggregate(final Configuration configuration,
                      final List<LaunchResults> launchesResults,
                      final Path outputDirectory) throws IOException {
       final JacksonContext context = configuration.requireContext(JacksonContext.class);
       final Path file = outputDirectory.resolve(FILE_NAME);
       try (OutputStream os = Files.newOutputStream(file)) {
           context.getValue().writeValue(os, getData(launchesResults));
       }
 }
----

We will cover all other classes by examples down below.

=== JS Plugin API overview

Front-end side of the Allure is built using link:http://backbonejs.org/[BackboneJS] framework.





=== Existing plugins
Several important Allure features are implemented as decoupled plugins that are stored independently under
the `plugins` folder of Allure Commandline distribution. Their usage can be managed by build profiles functionality
(jump to the (link to the section)[Commandline configuration]).


==== Custom Logo

Let's start with studuying how one of the simplest plugins works. In this section we will quickly
examine a plugin available in the Allure distribution which allows you to change a logo picture shown in
the upper-left corner of the report.

image::plugins_custom_logo.png[Custom logo in the report]

plugin sources directory structure:

[source]
----
/src
    /dist
        allure-plugin.yml
        /static
            custom-logo.svg
            styles.css
    build.gradle
----

Contents of `allure-plugin.yml`:

[source, yml]
----
id: custom-logo
name: Custom logo aggregator
description: The aggregator replaces default Allure logo with a custom one
cssFiles:
  - styles.css
----

* *custom-logo.svg* - is a vector graphics file with a logo to use
* *styles.css* - a css file that adds the style, that will override default logotype.

Contents of `styles.css`:

[source, css]
----
.side-nav__brand {
  background: url('custom-logo.svg') no-repeat left center;
  margin-left: 10px;
}
----

==== Behaviors

==== Junit

==== Screen Diff


