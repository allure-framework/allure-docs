Steps are any actions that constitute a testing scenario. Steps can be used in different testing scenarios.
They can: be parametrized, make checks, have nested steps, and create attachments. Each step has a name.

In order to define steps in Java code, you need to annotate the respective methods with **@Step** annotation.
When not specified, the step name is equal to the annotated method name.

Note that steps' mechanics was revised and now it supports smart fields' analysis.
In Allure 1 users had to specify indexes to refer which args' values they want to inject into step.
Allure 2 uses reflection-based approach, which provides deep fields' extraction by their names.

Assuming that you have the following entity:

[source, java, linenums]
----
public class User {

     private String name;
     private String password;
     ...
}
----

You can access these fields' values directly by name:

[source, java, linenums]
----
import io.qameta.allure.Step;

...

@Step("Type {user.name} / {user.password}.")
public void loginWith(User user) {
     ...
}
----

**Arrays** and **Collections** are supported as well.
So you don't need to explicitly override **toString()** for your custom objects anymore.

*Masking sensitive data:*

If you pass data to a @Step function that you don't want displayed in the Allure report,
such as passwords or credit card info, you can add the *@Secret* annotation to the parameter:

[source, java, linenums]
----
import io.qameta.allure.Secret;
import io.qameta.allure.Step;

...

@Step("Type {username} / {password}.")
public void loginWith(String username, @Secret String password) {
     ...
}
----

Now if you call `loginWith("user1", "pass1234");` the Allure report will record:

[source, java]
----
username: "user1"
password: "******"
----
